// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package enginepb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// EngineClient is the client API for Engine service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EngineClient interface {
	// hot页
	SubscribeHot(ctx context.Context, in *SubscribeHotRequest, opts ...grpc.CallOption) (Engine_SubscribeHotClient, error)
	// 行情(kline)
	SubscribeKline(ctx context.Context, in *SubscribeKlineRequest, opts ...grpc.CallOption) (Engine_SubscribeKlineClient, error)
	// 行情(trade)
	SubscribeTrade(ctx context.Context, in *SubscribeTradeRequest, opts ...grpc.CallOption) (Engine_SubscribeTradeClient, error)
	// 上新
	SubscribeNewPair(ctx context.Context, in *SubscribeNewPairRequest, opts ...grpc.CallOption) (Engine_SubscribeNewPairClient, error)
	// 搜索
	SearchToken(ctx context.Context, in *SearchTokenRequest, opts ...grpc.CallOption) (*SearchTokenResponse, error)
	// 获取kline
	GetKlineHistory(ctx context.Context, in *GetKlineHistoryRequest, opts ...grpc.CallOption) (*GetKlineHistoryResponse, error)
	// 获取基础信息
	GetBasicInfo(ctx context.Context, in *GetBasicInfoRequest, opts ...grpc.CallOption) (*GetBasicInfoResponse, error)
	// for block-parser
	OnNewTrade(ctx context.Context, in *OnNewTradeRequest, opts ...grpc.CallOption) (*OnNewTradeResponse, error)
	// for block-parser
	OnNewToken(ctx context.Context, in *OnNewTokenRequest, opts ...grpc.CallOption) (*OnNewTokenResponse, error)
	// for block-parser
	OnPairSync(ctx context.Context, in *OnPairSyncRequest, opts ...grpc.CallOption) (*OnPairSyncResponse, error)
}

type engineClient struct {
	cc grpc.ClientConnInterface
}

func NewEngineClient(cc grpc.ClientConnInterface) EngineClient {
	return &engineClient{cc}
}

func (c *engineClient) SubscribeHot(ctx context.Context, in *SubscribeHotRequest, opts ...grpc.CallOption) (Engine_SubscribeHotClient, error) {
	stream, err := c.cc.NewStream(ctx, &Engine_ServiceDesc.Streams[0], "/engine.api.Engine/SubscribeHot", opts...)
	if err != nil {
		return nil, err
	}
	x := &engineSubscribeHotClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Engine_SubscribeHotClient interface {
	Recv() (*SubscribeHotResponse, error)
	grpc.ClientStream
}

type engineSubscribeHotClient struct {
	grpc.ClientStream
}

func (x *engineSubscribeHotClient) Recv() (*SubscribeHotResponse, error) {
	m := new(SubscribeHotResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *engineClient) SubscribeKline(ctx context.Context, in *SubscribeKlineRequest, opts ...grpc.CallOption) (Engine_SubscribeKlineClient, error) {
	stream, err := c.cc.NewStream(ctx, &Engine_ServiceDesc.Streams[1], "/engine.api.Engine/SubscribeKline", opts...)
	if err != nil {
		return nil, err
	}
	x := &engineSubscribeKlineClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Engine_SubscribeKlineClient interface {
	Recv() (*SubscribeKlineResponse, error)
	grpc.ClientStream
}

type engineSubscribeKlineClient struct {
	grpc.ClientStream
}

func (x *engineSubscribeKlineClient) Recv() (*SubscribeKlineResponse, error) {
	m := new(SubscribeKlineResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *engineClient) SubscribeTrade(ctx context.Context, in *SubscribeTradeRequest, opts ...grpc.CallOption) (Engine_SubscribeTradeClient, error) {
	stream, err := c.cc.NewStream(ctx, &Engine_ServiceDesc.Streams[2], "/engine.api.Engine/SubscribeTrade", opts...)
	if err != nil {
		return nil, err
	}
	x := &engineSubscribeTradeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Engine_SubscribeTradeClient interface {
	Recv() (*SubscribeTradeResponse, error)
	grpc.ClientStream
}

type engineSubscribeTradeClient struct {
	grpc.ClientStream
}

func (x *engineSubscribeTradeClient) Recv() (*SubscribeTradeResponse, error) {
	m := new(SubscribeTradeResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *engineClient) SubscribeNewPair(ctx context.Context, in *SubscribeNewPairRequest, opts ...grpc.CallOption) (Engine_SubscribeNewPairClient, error) {
	stream, err := c.cc.NewStream(ctx, &Engine_ServiceDesc.Streams[3], "/engine.api.Engine/SubscribeNewPair", opts...)
	if err != nil {
		return nil, err
	}
	x := &engineSubscribeNewPairClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Engine_SubscribeNewPairClient interface {
	Recv() (*SubscribeNewPairResponse, error)
	grpc.ClientStream
}

type engineSubscribeNewPairClient struct {
	grpc.ClientStream
}

func (x *engineSubscribeNewPairClient) Recv() (*SubscribeNewPairResponse, error) {
	m := new(SubscribeNewPairResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *engineClient) SearchToken(ctx context.Context, in *SearchTokenRequest, opts ...grpc.CallOption) (*SearchTokenResponse, error) {
	out := new(SearchTokenResponse)
	err := c.cc.Invoke(ctx, "/engine.api.Engine/SearchToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *engineClient) GetKlineHistory(ctx context.Context, in *GetKlineHistoryRequest, opts ...grpc.CallOption) (*GetKlineHistoryResponse, error) {
	out := new(GetKlineHistoryResponse)
	err := c.cc.Invoke(ctx, "/engine.api.Engine/GetKlineHistory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *engineClient) GetBasicInfo(ctx context.Context, in *GetBasicInfoRequest, opts ...grpc.CallOption) (*GetBasicInfoResponse, error) {
	out := new(GetBasicInfoResponse)
	err := c.cc.Invoke(ctx, "/engine.api.Engine/GetBasicInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *engineClient) OnNewTrade(ctx context.Context, in *OnNewTradeRequest, opts ...grpc.CallOption) (*OnNewTradeResponse, error) {
	out := new(OnNewTradeResponse)
	err := c.cc.Invoke(ctx, "/engine.api.Engine/OnNewTrade", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *engineClient) OnNewToken(ctx context.Context, in *OnNewTokenRequest, opts ...grpc.CallOption) (*OnNewTokenResponse, error) {
	out := new(OnNewTokenResponse)
	err := c.cc.Invoke(ctx, "/engine.api.Engine/OnNewToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *engineClient) OnPairSync(ctx context.Context, in *OnPairSyncRequest, opts ...grpc.CallOption) (*OnPairSyncResponse, error) {
	out := new(OnPairSyncResponse)
	err := c.cc.Invoke(ctx, "/engine.api.Engine/OnPairSync", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EngineServer is the server API for Engine service.
// All implementations must embed UnimplementedEngineServer
// for forward compatibility
type EngineServer interface {
	// hot页
	SubscribeHot(*SubscribeHotRequest, Engine_SubscribeHotServer) error
	// 行情(kline)
	SubscribeKline(*SubscribeKlineRequest, Engine_SubscribeKlineServer) error
	// 行情(trade)
	SubscribeTrade(*SubscribeTradeRequest, Engine_SubscribeTradeServer) error
	// 上新
	SubscribeNewPair(*SubscribeNewPairRequest, Engine_SubscribeNewPairServer) error
	// 搜索
	SearchToken(context.Context, *SearchTokenRequest) (*SearchTokenResponse, error)
	// 获取kline
	GetKlineHistory(context.Context, *GetKlineHistoryRequest) (*GetKlineHistoryResponse, error)
	// 获取基础信息
	GetBasicInfo(context.Context, *GetBasicInfoRequest) (*GetBasicInfoResponse, error)
	// for block-parser
	OnNewTrade(context.Context, *OnNewTradeRequest) (*OnNewTradeResponse, error)
	// for block-parser
	OnNewToken(context.Context, *OnNewTokenRequest) (*OnNewTokenResponse, error)
	// for block-parser
	OnPairSync(context.Context, *OnPairSyncRequest) (*OnPairSyncResponse, error)
	mustEmbedUnimplementedEngineServer()
}

// UnimplementedEngineServer must be embedded to have forward compatible implementations.
type UnimplementedEngineServer struct {
}

func (UnimplementedEngineServer) SubscribeHot(*SubscribeHotRequest, Engine_SubscribeHotServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeHot not implemented")
}
func (UnimplementedEngineServer) SubscribeKline(*SubscribeKlineRequest, Engine_SubscribeKlineServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeKline not implemented")
}
func (UnimplementedEngineServer) SubscribeTrade(*SubscribeTradeRequest, Engine_SubscribeTradeServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeTrade not implemented")
}
func (UnimplementedEngineServer) SubscribeNewPair(*SubscribeNewPairRequest, Engine_SubscribeNewPairServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeNewPair not implemented")
}
func (UnimplementedEngineServer) SearchToken(context.Context, *SearchTokenRequest) (*SearchTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchToken not implemented")
}
func (UnimplementedEngineServer) GetKlineHistory(context.Context, *GetKlineHistoryRequest) (*GetKlineHistoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetKlineHistory not implemented")
}
func (UnimplementedEngineServer) GetBasicInfo(context.Context, *GetBasicInfoRequest) (*GetBasicInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBasicInfo not implemented")
}
func (UnimplementedEngineServer) OnNewTrade(context.Context, *OnNewTradeRequest) (*OnNewTradeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnNewTrade not implemented")
}
func (UnimplementedEngineServer) OnNewToken(context.Context, *OnNewTokenRequest) (*OnNewTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnNewToken not implemented")
}
func (UnimplementedEngineServer) OnPairSync(context.Context, *OnPairSyncRequest) (*OnPairSyncResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnPairSync not implemented")
}
func (UnimplementedEngineServer) mustEmbedUnimplementedEngineServer() {}

// UnsafeEngineServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EngineServer will
// result in compilation errors.
type UnsafeEngineServer interface {
	mustEmbedUnimplementedEngineServer()
}

func RegisterEngineServer(s grpc.ServiceRegistrar, srv EngineServer) {
	s.RegisterService(&Engine_ServiceDesc, srv)
}

func _Engine_SubscribeHot_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeHotRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EngineServer).SubscribeHot(m, &engineSubscribeHotServer{stream})
}

type Engine_SubscribeHotServer interface {
	Send(*SubscribeHotResponse) error
	grpc.ServerStream
}

type engineSubscribeHotServer struct {
	grpc.ServerStream
}

func (x *engineSubscribeHotServer) Send(m *SubscribeHotResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Engine_SubscribeKline_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeKlineRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EngineServer).SubscribeKline(m, &engineSubscribeKlineServer{stream})
}

type Engine_SubscribeKlineServer interface {
	Send(*SubscribeKlineResponse) error
	grpc.ServerStream
}

type engineSubscribeKlineServer struct {
	grpc.ServerStream
}

func (x *engineSubscribeKlineServer) Send(m *SubscribeKlineResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Engine_SubscribeTrade_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeTradeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EngineServer).SubscribeTrade(m, &engineSubscribeTradeServer{stream})
}

type Engine_SubscribeTradeServer interface {
	Send(*SubscribeTradeResponse) error
	grpc.ServerStream
}

type engineSubscribeTradeServer struct {
	grpc.ServerStream
}

func (x *engineSubscribeTradeServer) Send(m *SubscribeTradeResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Engine_SubscribeNewPair_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeNewPairRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EngineServer).SubscribeNewPair(m, &engineSubscribeNewPairServer{stream})
}

type Engine_SubscribeNewPairServer interface {
	Send(*SubscribeNewPairResponse) error
	grpc.ServerStream
}

type engineSubscribeNewPairServer struct {
	grpc.ServerStream
}

func (x *engineSubscribeNewPairServer) Send(m *SubscribeNewPairResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Engine_SearchToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EngineServer).SearchToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/engine.api.Engine/SearchToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EngineServer).SearchToken(ctx, req.(*SearchTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Engine_GetKlineHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetKlineHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EngineServer).GetKlineHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/engine.api.Engine/GetKlineHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EngineServer).GetKlineHistory(ctx, req.(*GetKlineHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Engine_GetBasicInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBasicInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EngineServer).GetBasicInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/engine.api.Engine/GetBasicInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EngineServer).GetBasicInfo(ctx, req.(*GetBasicInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Engine_OnNewTrade_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OnNewTradeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EngineServer).OnNewTrade(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/engine.api.Engine/OnNewTrade",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EngineServer).OnNewTrade(ctx, req.(*OnNewTradeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Engine_OnNewToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OnNewTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EngineServer).OnNewToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/engine.api.Engine/OnNewToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EngineServer).OnNewToken(ctx, req.(*OnNewTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Engine_OnPairSync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OnPairSyncRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EngineServer).OnPairSync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/engine.api.Engine/OnPairSync",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EngineServer).OnPairSync(ctx, req.(*OnPairSyncRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Engine_ServiceDesc is the grpc.ServiceDesc for Engine service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Engine_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "engine.api.Engine",
	HandlerType: (*EngineServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SearchToken",
			Handler:    _Engine_SearchToken_Handler,
		},
		{
			MethodName: "GetKlineHistory",
			Handler:    _Engine_GetKlineHistory_Handler,
		},
		{
			MethodName: "GetBasicInfo",
			Handler:    _Engine_GetBasicInfo_Handler,
		},
		{
			MethodName: "OnNewTrade",
			Handler:    _Engine_OnNewTrade_Handler,
		},
		{
			MethodName: "OnNewToken",
			Handler:    _Engine_OnNewToken_Handler,
		},
		{
			MethodName: "OnPairSync",
			Handler:    _Engine_OnPairSync_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeHot",
			Handler:       _Engine_SubscribeHot_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeKline",
			Handler:       _Engine_SubscribeKline_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeTrade",
			Handler:       _Engine_SubscribeTrade_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeNewPair",
			Handler:       _Engine_SubscribeNewPair_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "engine/engine.proto",
}
